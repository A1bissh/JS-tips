/* Побитовые операторы интерпретируют операнды как 
последовательность из 32 битов (нулей и единиц). 
Они производят операции, используя двоичное представление 
числа, и возвращают новую последовательность из 
32 бит (число) в качестве результата. */

/* ФОРМАТ 32 БИТНОГО ЦЕЛОГО ЧИСЛА СО ЗНАКОМ
Побитовые операторы в JavaScript работают с 
32-битными целыми числами в их двоичном представлении.
Это представление называется «32-битное целое 
со знаком, старшим битом слева и дополнением до двойки».
Разберём, как устроены числа внутри подробнее, 
это необходимо знать для битовых операций с ними. */

//Старший бит слева – это научное название для самого обычного порядка записи цифр 
//(от большего разряда к меньшему). При этом, если больший разряд отсутствует, то соответствующий бит равен нулю.
//Примеры представления чисел в двоичной системе:
a = 0; // 00000000000000000000000000000000
a = 1; // 00000000000000000000000000000001
a = 2; // 00000000000000000000000000000010
a = 3; // 00000000000000000000000000000011
a = 255; // 00000000000000000000000011111111

//Двоичный вид числа, обратного данному (например, 5 и -5) получается путём обращения всех битов с прибавлением 1.
//  Чтобы получить отрицательное число, первый шаг – обратить биты числа: заменить 0 на 1, а 1 на 0:
//  Второй шаг – к полученному двоичному числу прибавить единицу, обычным двоичным сложением:

/*  Принцип дополнения до двойки делит все двоичные представления 
    на два множества: если крайний-левый бит равен 0 – число положительное, 
    если 1 – число отрицательное. Поэтому этот бит называется знаковым битом.
*/


/* СПИСОК ПОБИТОВЫХ ОПЕРАТОРОВ

Побитовое И (AND)	                a & b	    Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
Побитовое ИЛИ (OR)	                a | b	    Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
Побитовое исключающее ИЛИ (XOR)	    a ^ b	    Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
Побитовое НЕ (NOT)	                ~a	        Заменяет каждый бит операнда на противоположный.
Левый сдвиг	                        `a << b`	Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
Правый сдвиг, переносящий знак	    `a >> b`	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
Правый сдвиг с заполнением нулями	`a >>> b`	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.

*/

/* 
Побитовые операторы работают следующим образом:
1)Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. 
Дробная часть, если она есть, отбрасывается.
2)Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с 
соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. 
Оператор применяется к каждой паре бит, давая соответствующий бит результата.
3)Получившаяся в результате последовательность бит интерпретируется как обычное число.
*/


/*
Исключающее ИЛИ в шифровании
Исключающее или можно использовать для шифрования, 
так как эта операция полностью обратима. 
Двойное применение исключающего ИЛИ с тем же аргументом даёт исходное число.
Иначе говоря, верна формула: a ^ b ^ b == a.
Пускай Вася хочет передать Пете секретную информацию data. 
Эта информация заранее превращена в число, например строка 
интерпретируется как последовательность кодов символов.
Вася и Петя заранее договариваются о числовом ключе шифрования key.
*/
//шифр
var data = 68356747668685;
var key = 45245354234255;
var encryption = data ^ key;
//дешифр
data = encryption ^ key;
/* Конечно, такое шифрование поддаётся частотному анализу и 
другим методам дешифровки, поэтому современные алгоритмы используют операцию 
XOR ^ как одну из важных частей более сложной многоступенчатой схемы. */


/* << (Битовый сдвиг влево)
Операторы битового сдвига принимают два операнда. 
Первый – это число для сдвига, а второй – количество битов, 
которые нужно сдвинуть в первом операнде.
Оператор << сдвигает первый операнд на указанное число битов влево. 
Лишние биты отбрасываются, справа добавляются нулевые биты.
Например, 9 << 2 даст 36
Правый битовый, переносящий знак(>>) работает почти так же, но добавляются копии крайних левых битов(столько, на сколько сдвинулись)
Правый битовый с заполнением нулями отбрасывает неободимые справа дописывает нули слева
*/