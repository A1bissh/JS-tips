//Операторы сравнения и логическое значение

/*
-Больше/меньше: a > b, a < b.
-Больше/меньше или равно: a >= b, a <= b.
-Равно a == b. Для сравнения используется два символа равенства '='. 
  Один символ a = b означал бы присваивание.
-«Не равно». В математике он пишется как ≠, в JavaScript – знак 
  равенства с восклицательным знаком перед ним !=.
*/

/* Как и другие операторы, сравнение возвращает значение. Это значение имеет логический тип.
Существует всего два логических значения:
    -true – имеет смысл «да», «верно», «истина».
    -false – означает «нет», «неверно», «ложь».
 */
alert(2 > 1); // true, верно
alert(2 == 1); // false, неверно
alert(2 != 1); // true
var a = true; // присваивать явно
var b = 3 > 4; // или как результат сравнения
alert(b); // false
alert(a == b); // (true == false) неверно, выведет false

//СРАВНЕНИЕ СТРОК
/* Строки сравниваются побуквенно: */
alert('Б' > 'А'); // true
// WARNING!!! JavaScript использует кодировку Unicode.
/* При этом сравниваются численные коды символов. В частности, 
код у символа Б больше, чем у А, поэтому и результат сравнения такой.
В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.
Поэтому регистр имеет значение: */
alert('а' > 'Я'); // true, строчные буквы больше прописных
/* Если строка состоит из нескольких букв, то сравнение осуществляется 
как в телефонной книжке или в словаре. Сначала сравниваются первые 
буквы, потом вторые, и так далее, пока одна не будет больше другой.
При этом любая буква больше отсутствия буквы:
 */
alert('Привет' > 'Прив'); // true, так как 'е' больше чем "ничего".

//СРАВНЕНИЕ РАЗНЫХ ТИПОВ 
/* При сравнении значений разных типов, 
используется числовое преобразование. Оно применяется к обоим значениям.
Например: */
alert('2' > 1); // true, сравнивается как 2 > 1
alert('01' == 1); // true, сравнивается как 1 == 1
alert(false == 0); // true, false становится числом 0
alert(true == 1); // true, так как true становится числом 1.


// СТРОГОЕ РАВЕНСТВО/неравенство
/* == при сравнении разных типов не отличает false от 0, 
а === или !== отличает, они выдают false всегда, если типы разные
*/
alert(0 === false); // false, т.к. типы различны

//СРАВНЕНИЕ "null" и "undefined"
/* Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так.
Они ведут себя по-другому.
Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
При преобразовании в число null становится 0, а undefined становится NaN.
Посмотрим забавные следствия.
 */
alert(null > 0); // false
alert(null == 0); // false
//Итак, мы получили, что null не больше и не равен нулю. А теперь…
alert(null >= 0); // true

//Значение undefined вообще нельзя сравнивать:
alert(undefined > 0); // false (1)
alert(undefined < 0); // false (2)
alert(undefined == 0); // false (3)
/*Сравнения (1) и (2) дают false потому, что undefined при преобразовании 
к числу даёт NaN. А значение NaN по стандарту устроено так, что сравнения 
==, <, >, <=, >= и даже === с ним возвращают false.
Проверка равенства (3) даёт false, потому что в стандарте явно прописано, 
что undefined равно лишь null и ничему другому. */